'use strict';
const oracledb = require('oracledb')
const writer = require('../../utils/writer.js')
const dbUtils = require('./utils')


/**
 * Return version information
 *
 * returns ApiVersion
 **/
exports.getVersion = async function(userObject) {
  try {
    return (dbUtils.version)
  }
  catch(err) {
    throw ( writer.respondWithCode ( 500, {message: err.message,stack: err.stack} ) )
  }
}

exports.replaceAppData = async function (importOpts, appData, userObject ) {
  function dmlObjectFromAppData (appdata) {
    let {packages, assets, users, reviews} = appdata
    let dml = {
      preload: [
        `ALTER TABLE STIGMAN.REVIEWS MODIFY CONSTRAINT FK_REVIEWS_1 DISABLE`,
        `ALTER TABLE STIGMAN.REVIEWS MODIFY CONSTRAINT INDEX_2_1_1 DISABLE`,
        `ALTER TABLE STIGMAN.REVIEWS MODIFY CONSTRAINT PRIMARY_27 DISABLE`,
        `ALTER TABLE STIGMAN.REVIEWS_HISTORY MODIFY CONSTRAINT PRIMARY_28 DISABLE`,        
        `ALTER TABLE STIGMAN.REVIEWS DISABLE ALL TRIGGERS`,
        `ALTER TABLE STIGMAN.ASSETS DISABLE ALL TRIGGERS`,
        `ALTER INDEX STIGMAN.INDEX_2_1_1 UNUSABLE`,
        `ALTER INDEX STIGMAN.INDEX_4 UNUSABLE`,
        `ALTER INDEX STIGMAN.PRIMARY_27 UNUSABLE`,
        `ALTER INDEX STIGMAN.INDEX_3_3 UNUSABLE`,
        `ALTER INDEX STIGMAN.INDEX_STATUSID UNUSABLE`,
        `ALTER INDEX STIGMAN.INDEX_ACTIVITYTYPE UNUSABLE`,
        `ALTER INDEX STIGMAN.INDEX_ASSETID UNUSABLE`,
        `ALTER INDEX STIGMAN.INDEX_COLUMNNAME UNUSABLE`,
        `ALTER INDEX STIGMAN.INDEX_RULEID UNUSABLE`,
        `ALTER INDEX STIGMAN.PRIMARY_28 UNUSABLE`
        
      ],
      postload: [
        `ALTER INDEX STIGMAN.INDEX_2_1_1 REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.INDEX_4 REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.PRIMARY_27 REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.INDEX_3_3 REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.INDEX_STATUSID REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.INDEX_ACTIVITYTYPE REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.INDEX_ASSETID REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.INDEX_COLUMNNAME REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.INDEX_RULEID REBUILD ONLINE`,
        `ALTER INDEX STIGMAN.PRIMARY_28 REBUILD ONLINE`,
        `ALTER TABLE STIGMAN.ASSET_PACKAGE_MAP MODIFY APID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.ASSETS MODIFY ASSETID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.PACKAGES MODIFY PACKAGEID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.REVIEWS MODIFY REVIEWID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.STATS_ASSET_STIG MODIFY ID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.STIG_ASSET_MAP MODIFY SAID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.USER_DATA MODIFY ID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.USER_STIG_ASSET_MAP MODIFY ID GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH LIMIT VALUE)`,
        `ALTER TABLE STIGMAN.REVIEWS ENABLE ALL TRIGGERS`,
        `ALTER TABLE STIGMAN.ASSETS ENABLE ALL TRIGGERS`,
        `ALTER TABLE STIGMAN.REVIEWS MODIFY CONSTRAINT FK_REVIEWS_1 ENABLE`,
        `ALTER TABLE STIGMAN.REVIEWS MODIFY CONSTRAINT INDEX_2_1_1 ENABLE`,
        `ALTER TABLE STIGMAN.REVIEWS MODIFY CONSTRAINT PRIMARY_27 ENABLE`,
        `ALTER TABLE STIGMAN.REVIEWS_HISTORY MODIFY CONSTRAINT PRIMARY_28 ENABLE`
      ],
      packages: {
        sqlDelete: `DELETE FROM stigman.packages`,
        sqlInsert: `INSERT INTO
        stigman.packages (
          packageId,
          NAME, 
          EMASSID,
          REQRAR,
          POCNAME,
          POCEMAIL,
          POCPHONE 
        ) VALUES (
          :packageId, :name, :emassId, :reqRar, :pocName, :pocEmail, :pocPhone
        )`,
        insertBinds: []
      },
      users: {
        sqlDelete: `DELETE FROM stigman.user_data`,
        sqlInsert: `INSERT INTO
        stigman.user_data (
          id,
          cn, 
          name,
          dept,
          roleId,
          canAdmin
        ) VALUES (
          :userId, :username, :display, :dept, :role, :canAdmin
        )`,
        insertBinds: []
      },
      assets: {
        sqlDelete: `DELETE FROM stigman.assets`,
        sqlInsert: `INSERT INTO stigman.assets (
          assetId,
          name,
          ip,
          dept,
          nonnetwork
        ) VALUES (
          :assetId, :name, :ip, :dept, :nonnetwork
        )`,
        insertBinds: []
      },
      assetPackageMap: {
        sqlDelete: `DELETE FROM stigman.asset_package_map`,
        sqlInsert: `INSERT INTO stigman.asset_package_map (
          assetId,
          packageId
        ) VALUES (
          :assetId, :packageId
        )`,
        insertBinds: []
      },
      stigAssetMap: {
        sqlDelete: `DELETE FROM stigman.stig_asset_map`,
        sqlInsert: `INSERT INTO stigman.stig_asset_map (
          assetId,
          stigId
        ) VALUES (
          :assetId, :benchmarkId
        )`,
        insertBinds: []
      },
      userStigAssetMap: {
        sqlDelete: `DELETE FROM stigman.user_stig_asset_map`,
        sqlInsert: `INSERT INTO stigman.user_stig_asset_map (
          userId,
          saId
        ) VALUES (
          :userId,
          (SELECT saId from stigman.stig_asset_map WHERE stigId=:benchmarkId and assetId=:assetId)
        )`,
        insertBinds: []
      },
      reviewsHistory: {
        sqlDelete: `TRUNCATE TABLE stigman.reviews_history`,
        sqlInsert: `INSERT INTO stigman.reviews_history (
          assetId,
          ruleId,
          activityType,
          columnName,
          oldValue,
          newValue,
          userId,
          ts
        ) VALUES (
          :assetId, :ruleId, :activityType, :columnName, :oldValue, :newValue, :userId, :ts
        )`,
        insertBinds: [],
        bindDefs: {
          assetId: {type: oracledb.DB_TYPE_NUMBER},
          ruleId: {type: oracledb.DB_TYPE_VARCHAR, maxSize: 45},
          activityType: {type: oracledb.DB_TYPE_VARCHAR, maxSize: 45},
          columnName: {type: oracledb.DB_TYPE_VARCHAR, maxSize: 45},
          oldValue: {type: oracledb.DB_TYPE_VARCHAR, maxSize: 32766},
          newValue: {type: oracledb.DB_TYPE_VARCHAR, maxSize: 32766},
          userId: {type: oracledb.DB_TYPE_NUMBER},
          ts: {type: oracledb.DB_TYPE_DATE}
        }
      },
      reviews: {
        sqlDelete: `TRUNCATE TABLE stigman.reviews`,
        sqlInsert: `INSERT INTO stigman.reviews (
          assetId,
          ruleId,
          stateId,
          stateComment,
          actionId,
          actionComment,
          userId,
          autoState,
          ts,
          rejectText,
          rejectUserId,
          statusId
        ) VALUES (
          :assetId, :ruleId, :state, :stateComment, :action, :actionComment,
          :userId, :autoState, :ts, :rejectText, :rejectUserId, :status
        )`,
        // sqlInsert: `INSERT INTO stigman.reviews (
        //   assetId,
        //   ruleId
        // ) VALUES (
        //   :assetId, :ruleId
        // )`,
        insertBinds: []
      }
    }

    // Process appdata object

    // PACKAGES
    for (const p of packages) {
      p.reqRar = p.reqRar ? 1 : 0
    }
    dml.packages.insertBinds = packages

    // USER_DATA
    for (const u of users) {
      u.canAdmin = u.canAdmin ? 1 : 0
      u.role = dbUtils.USER_ROLE[u.role].id
    }
    dml.users.insertBinds = users

    // ASSETS, ASSET_PACAKGE_MAP, STIG_ASSET_MAP, USER_STIG_ASSET_MAP
    for (const asset of assets) {
      let { packageIds, stigReviewers, ...assetFields} = asset
      assetFields.nonnetwork = assetFields.nonnetwork ? 1: 0
      delete assetFields.scanexempt // TODO: Remove this when scanexempt no longer provided
      dml.assets.insertBinds.push(assetFields)
      let assetId = assetFields.assetId
      for (const packageId of packageIds) {
        dml.assetPackageMap.insertBinds.push([assetId, packageId])
      }
      for (const sr of stigReviewers) {
        dml.stigAssetMap.insertBinds.push({
          assetId: assetId,
          benchmarkId: sr.benchmarkId
        })
        if (sr.userIds && sr.userIds.length > 0) {
          for (const userId of sr.userIds) {
            dml.userStigAssetMap.insertBinds.push({
              userId: userId,
              benchmarkId: sr.benchmarkId,
              assetId: assetId
            })
          }
        }
      }
    }

    // REVIEWS, REVIEWS_HISTORY
    for (const review of reviews) {
      review.autoState = review.autoState ? 1 : 0
      review.state = dbUtils.REVIEW_STATE_ABBR[review.state].id
      review.action = review.action ? dbUtils.REVIEW_ACTION_STR[review.action] : null
      review.status = review.status ? dbUtils.REVIEW_STATUS_STR[review.status] : 0
      review.ts = new Date(review.ts)
      delete review.reviewId
      for (const h of review.history) {
        h.ts = new Date(h.ts)
        h.assetId = review.assetId
        h.ruleId = review.ruleId
        dml.reviewsHistory.insertBinds.push(h)
      }
      delete review.history
      dml.reviews.insertBinds.push(review)

    }
    dml.reviews.insertBinds = reviews

    return dml
  }

  let connection
  try {
    let result, hrstart, hrend, tableOrder, dml, stats = {}
    let totalstart = process.hrtime() 

    hrstart = process.hrtime() 
    dml = dmlObjectFromAppData(appData)
    hrend = process.hrtime(hrstart)
    stats.dmlObject = `Built in ${hrend[0]}s  ${hrend[1] / 1000000}ms`

    // Connect to Oracle, has transaction by default
    connection = await oracledb.getConnection()

    // Preload
    hrstart = process.hrtime() 
    for (const sql of dml.preload) {
      console.log(sql)
      result = await connection.execute(sql)
    }
    hrend = process.hrtime(hrstart)
    stats.preload = `${result.rowsAffected} in ${hrend[0]}s  ${hrend[1] / 1000000}ms`

    // Deletes
    tableOrder = [
      'reviewsHistory',
      'reviews',
      'userStigAssetMap',
      'stigAssetMap',
      'assetPackageMap',
      'packages',
      'assets',
      'users'
    ]
    for (const table of tableOrder) {
      hrstart = process.hrtime() 
      result = await connection.execute(dml[table].sqlDelete)
      hrend = process.hrtime(hrstart)
      stats[table] = {}
      stats[table].delete = `${result.rowsAffected} in ${hrend[0]}s  ${hrend[1] / 1000000}ms`
    }

    // Inserts
    tableOrder = [
      'packages',
      'users',
      'assets',
      'assetPackageMap',
      'stigAssetMap',
      'userStigAssetMap',
      'reviews',
      'reviewsHistory'
    ]
    for (const table of tableOrder) {
      if (dml[table].insertBinds.length > 0) {
        hrstart = process.hrtime() 
        result = await connection.executeMany(dml[table].sqlInsert, dml[table].insertBinds)
        hrend = process.hrtime(hrstart)
        stats[table].insert = `${result.rowsAffected} in ${hrend[0]}s  ${hrend[1] / 1000000}ms`
      }
    }

    // Commit
    hrstart = process.hrtime() 
    connection.commit()
    hrend = process.hrtime(hrstart)
    stats.commit = `${result.rowsAffected} in ${hrend[0]}s  ${hrend[1] / 1000000}ms`

    // Postload
    hrstart = process.hrtime() 
    for (const sql of dml.postload) {
      result = await connection.execute(sql)
    }
    hrend = process.hrtime(hrstart)
    stats.postload = `${result.rowsAffected} in ${hrend[0]}s  ${hrend[1] / 1000000}ms`

    // Total time calculation
    hrend = process.hrtime(totalstart)
    stats.total = `TOTAL in ${hrend[0]}s  ${hrend[1] / 1000000}ms`

    return (stats)
  }
  catch (err) {
    if (typeof connection !== 'undefined') {
      await connection.rollback()
    }
    throw err
  }
  finally {
    if (typeof connection !== 'undefined') {
      await connection.close()
    }
  }
}
